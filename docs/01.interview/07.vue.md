---
title: vue框架
date: 2021-09-06 17:30:06
permalink: /pages/d4dc7d/
categories:
  - interview
tags:
  -
---

## Vue 的理解，优缺点

Vue 是一个构建数据驱动的渐进性框架，它的目标是通过API 实现响应数据绑定和视图更新

优点：渐进式，组件化，轻量级，虚拟 dom，响应式，单页面路由，数据与视图分开

缺点：单页面不利于 seo，不支持 IE8 以下，首屏加载时间长

## MVVM

全称： `Model-View-ViewModel` ， `Model` 表示数据模型层。 `view` 表示视图层， `ViewModel` 是 `View` 和 Model 层的桥梁，数据绑定到 `viewModel` 层并自动渲染到页面中，视图变化通知 `viewModel` 层更新数据。

## 为什么说 Vue 是一个渐进式框架？

渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用 component 就用，不用也行，你想用 vuex 就用，不用也可以

## vue 组件通讯方式

- props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的、
- $parent,$children 获取当前组件的父组件和当前组件的子组件
- $attrs 和$listeners A->B->C。解决深层组件间的通信， Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题
- 父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。
- $refs 获取组件实例
- envetBus 兄弟组件数据传递
- vuex 状态管理

## Vuex 的 Mutation 和 Action 的区别吗

Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。

Vuex主要包括以下几个核心模块：

1. `State`：定义了应用的状态数据

2. `Getter`：在 store 中定义“getter”（可以认为是 store 的计算属性），就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算

3. `Mutation`：是唯一更改 store 中状态的方法，且必须是同步函数

4. `Action`：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中

## vue生命周期

每个Vue实例在创建时都会经过一系列的初始化过程，vue的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件

- `create阶段`：vue实例被创建

beforeCreate: 创建前，此时data和methods中的数据都还没有初始化

created： 创建完毕，data中有值，未挂载

-`mount阶段`： vue实例被挂载到真实DOM节点

beforeMount：可以发起服务端请求，去数据

mounted: 此时可以操作DOM

- `update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染

beforeUpdate :更新前

updated：更新后

-`destroy阶段`：vue实例被销毁

beforeDestroy：实例被销毁前，此时可以手动销毁一些方法

destroyed:销毁后

## Vue底层实现原理

vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调
Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观

**`Observer（数据监听器）`** Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher

**`Watcher（订阅者）`** Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：

  1. 在自身实例化时往属性订阅器(dep)里面添加自己
  2. 自身必须有一个update()方法
  3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调

**`Compile（指令解析器）`** Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图

## computed与watch

通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。

- `watch` 属性监听 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用
- `computed` 计算属性 属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed中的函数必须用return返回最终的结果 computed更高效，优先使用。data 不改变，computed 不更新。

`使用场景` computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能。watch：当一条数据影响多条数据的时候使用，例：搜索数据

## key 的作用是什么？

- Key 的作用：
主要用来在虚拟 DOM 的 diff 算法中，在新旧节点的对比时辨别 vnode ，使用 key 时，Vue 会基于 key 的变化重新排列元素顺序，尽可能的复用页面元素，只找出必须更新的DOM，最终可以减少DOM操作。常见的列子是结合 v-for 来进行列表渲染，或者用于强制替换元素/组件。
- 设置 Key 的好处：
  - （1）数据更新时，可以尽可能的减少DOM操作；
  - （2）列表渲染时，可以提高列表渲染的效率，提高页面的性能；

## v-model中的实现原理

v-model 可以看成是 value+input 方法的语法糖（组件）。原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来。

## 为什么Vue采用异步渲染

Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。
 dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）。

## nextTick的实现原理是什么？

在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

## 路由原理 history 和 hash 两种路由方式的特点

- hash 模式

  - `实现原理`：location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

  - 可以为 hash 的改变添加监听事件 `window.addEventListener("hashchange", funcRef, false);`

  - `特点`：每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，实现前端路由“更新视图但不重新请求页面”的功能了

- history 模式
  - `实现原理`：利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。
这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。
  - `特点`：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

## 路由懒加载的方式

- Vue异步组件技术

- 动态import语法

- require.ensure()

```js
// 异步组件
{
  path: '/Demo',
  name: 'Demo',
  //打包后，每个组件单独生成一个chunk文件
  component: reslove => require(['../views/Demo'], resolve)
}
//动态import 默认将每个组件，单独打包成一个js文件
const Demo = () => import('../views/Demo')
// require.ensure
const Demo = r => require.ensure([], () => r(require('../views/Demo')), 'Demo')
```

## keep-alive的实现

- 作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染

- 场景：tabs标签页 后台导航，vue性能优化

- 原理：Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。

## 异步组件

Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。
`优点`：节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题。

一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：

```js
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})
```

使用局部注册的时候,可以直接提供一个返回 Promise 的函数：

```js
new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
```

## 什么是虚拟DOM？

## diff算法

DOM操作是很耗性能的，因此需要尽量减少DOM操作。找出本次DOM必须更新的节点来更新，其他的不更新，这个“找出”的过程，就需要diff算法。

- diff算法主要执行过程：

  - patch(container, vnode) ，首次渲染，将 container 转为 vnode，并对比新旧 VNode 是否相同节点然后更新DOM
  - patch(vnode, newVnode) ，数据改变二次渲染，对比新旧 VNode 是否相同节点然后更新DOM
  - createElm(vnode, insertedVnodeQueue)，先执行用户的 init 钩子函数，然后把 vnode 转换成真实 DOM（此时没有渲染到页面），最后返回新创建的 DOM
  - updateChildren(elm, oldCh, ch, insertedVnodeQueue), 如果 VNode 有子节点，并且与旧VNode子节点不相同则执行 updateChildren()，比较子节点的差异并更新到DOM

## 参考资料

<https://vue-js.com/learn-vue/> Vue 源码系列-Vue 中文社区

<https://ustbhuangyi.github.io/vue-analysis/> Vue.js 技术揭秘
