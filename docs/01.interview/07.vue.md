---
title: vue框架
date: 2021-09-06 17:30:06
permalink: /pages/d4dc7d/
categories:
  - interview
tags:
  -
---

## Vue 的优缺点

优点：渐进式，组件化，轻量级，虚拟 dom，响应式，单页面路由，数据与视图分开

缺点：单页面不利于 seo，不支持 IE8 以下，首屏加载时间长

## 为什么说 Vue 是一个渐进式框架？

渐进式：通俗点讲就是，你想用啥你就用啥，咱也不强求你。你想用 component 就用，不用也行，你想用 vuex 就用，不用也可以

## VueRouter 的原理

## Vuex 的 Mutation 和 Action 的区别吗

Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。

Vuex主要包括以下几个核心模块：

1. `State`：定义了应用的状态数据

2. `Getter`：在 store 中定义“getter”（可以认为是 store 的计算属性），就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算

3. `Mutation`：是唯一更改 store 中状态的方法，且必须是同步函数

4. `Action`：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中

## vue生命周期

每个Vue实例在创建时都会经过一系列的初始化过程，vue的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件

- `create阶段`：vue实例被创建

beforeCreate: 创建前，此时data和methods中的数据都还没有初始化

created： 创建完毕，data中有值，未挂载

-`mount阶段`： vue实例被挂载到真实DOM节点

beforeMount：可以发起服务端请求，去数据

mounted: 此时可以操作DOM

- `update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染

beforeUpdate :更新前

updated：更新后

-`destroy阶段`：vue实例被销毁

beforeDestroy：实例被销毁前，此时可以手动销毁一些方法

destroyed:销毁后

## Vue底层实现原理

vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调
Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观

**`Observer（数据监听器）`** Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher

**`Watcher（订阅者）`** Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：

  1. 在自身实例化时往属性订阅器(dep)里面添加自己
  2. 自身必须有一个update()方法
  3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调

**`Compile（指令解析器）`** Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图

## computed与watch

通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。

- `watch` 属性监听 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用
- `computed` 计算属性 属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed中的函数必须用return返回最终的结果 computed更高效，优先使用。data 不改变，computed 不更新。

`使用场景` computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能。watch：当一条数据影响多条数据的时候使用，例：搜索数据

## nextTick的实现原理是什么？

在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

## keep-alive的实现

- 作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染

- 场景：tabs标签页 后台导航，vue性能优化

- 原理：Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。

## 参考资料

<https://vue-js.com/learn-vue/> Vue 源码系列-Vue 中文社区

<https://ustbhuangyi.github.io/vue-analysis/> Vue.js 技术揭秘

<https://juejin.cn/post/6984210440276410399#heading-6>
